open! Core
open Eio.Std

let version = "2.2.1"

let header = sprintf "/* Generated by okTurtles/strings v%s */\n\n" version

let plural i = if i = 1 then "" else "s"

type counts = {
  vue: int ref;
  pug: int ref;
  html: int ref;
  js: int ref;
  ts: int ref;
}

type common_options = {
  outdir: string;
  targets: string list;
  template_script: Vue.template_script;
  slow_pug: bool;
}

type action =
  | Debug of Vue.Debug.t
  | Run

type traversal = {
  rootlen: int;
  table: String.Set.t String.Table.t;
  template_script: Vue.template_script;
  slow_pug: bool;
  counts: counts;
}

let process_file env traversal count filename ~f:get_collector =
  (* TODO: semaphore/limiter? *)
  incr count;
  let (collector : Utils.Collector.t) =
    Eio.Path.with_open_in Eio.Path.(env#fs / filename) get_collector
  in
  let handler string =
    let realname = String.slice filename traversal.rootlen 0 in
    String.Table.update traversal.table string ~f:(function
      | None -> String.Set.add String.Set.empty realname
      | Some set -> String.Set.add set realname )
  in
  Utils.Collector.render_errors collector
  |> Option.iter ~f:(fun s -> Eio.Flow.copy_string (sprintf "%s\n" s) env#stderr);
  Queue.iter collector.strings ~f:handler;
  Vue.collect_from_possible_scripts collector traversal.template_script ~on_string:handler

let rec process_dir env traversal ~path = function
| "node_modules" -> ()
| filename -> (
  match Utils.Io.stat path, lazy (String.slice filename (-4) 0), lazy (String.slice filename (-3) 0) with
  | { st_kind = S_REG; _ }, _, (lazy ".js") when String.is_suffix ~suffix:".js" filename ->
    process_file env traversal traversal.counts.js path ~f:(fun flow ->
      let collector = Utils.Collector.create ~path in
      let source = Utils.Io.load_flow flow in
      Parsing.Js.extract_to_collector collector source;
      collector )
  | { st_kind = S_REG; _ }, _, (lazy ".ts") ->
    process_file env traversal traversal.counts.ts path ~f:(fun flow ->
      let collector = Utils.Collector.create ~path in
      let source = Utils.Io.load_flow flow in
      Quickjs.extract_to_collector collector Typescript source;
      collector )
  | { st_kind = S_REG; _ }, (lazy ".vue"), _ ->
    process_file env traversal traversal.counts.vue path ~f:(fun flow ->
      let collector = Utils.Collector.create ~path in
      let languages = Vue.parse ~path ~slow_pug:traversal.slow_pug flow in
      Vue.collect_from_languages collector languages;
      collector )
  | { st_kind = S_REG; _ }, (lazy ".pug"), _ ->
    process_file env traversal traversal.counts.pug path ~f:(fun flow ->
      let collector = Utils.Collector.create ~path in
      let source = Utils.Io.load_flow flow in
      let slow_parse () = Quickjs.extract_to_collector collector Pug source in
      (match traversal.slow_pug with
      | true -> slow_parse ()
      | false ->
        let on_ok parsed = Parsing.Pug.collect collector parsed in
        let on_error ~msg:_ = slow_parse () in
        Parsing.(Basic.exec_parser ~on_ok ~on_error (Pug.parser (Basic.make_string_parsers ())))
          ~path ~language_name:"Pug" source);
      collector )
  | { st_kind = S_REG; _ }, _, _ when String.is_suffix filename ~suffix:".html" ->
    process_file env traversal traversal.counts.html path ~f:(fun flow ->
      let collector = Utils.Collector.create ~path in
      let on_ok parsed =
        Parsing.Html.collect collector parsed;
        collector
      in
      Parsing.Basic.exec_parser_eio ~on_ok Parsing.Html.parser ~path ~language_name:"HTML" flow )
  | { st_kind = S_DIR; _ }, _, _ -> traverse env traversal path
  | _ -> () )

and traverse env traversal directory =
  (* TODO: ~max_fibers *)
  Eio.Path.with_open_dir Eio.Path.(env#fs / directory) Eio.Path.read_dir
  |> Fiber.List.iter (fun entry ->
       let path = Filename.concat directory entry in
       process_dir env traversal ~path entry )

let fmt s = Yojson.Basic.to_string (`String s)

let json_pair left right first =
  sprintf "%s\n  %s: %s"
    ( if !first
      then (
        first := false;
        "" )
      else "," )
    left right

let write_english env ~outdir english =
  let time = Utils.Timing.start () in
  let path_strings = Filename.concat outdir "english.strings" in
  let path_json = Filename.concat outdir "english.json" in
  let first = ref true in
  Switch.run (fun sw ->
    let file_strings =
      Eio.Path.open_out ~sw ~create:Utils.Io.flags Eio.Path.(env#fs / outdir / "english.strings")
    in
    let file_json =
      Eio.Path.open_out ~sw ~create:Utils.Io.flags Eio.Path.(env#fs / outdir / "english.json")
    in
    let module W = Eio.Buf_write in
    W.with_flow file_strings @@ fun w_strings ->
    W.with_flow file_json @@ fun w_json ->
    (* Write headers of both *)
    W.string w_strings header;
    W.char w_json '{';
    (* Switch to a map to preserve order as much as possible and therefore reduce merge conflicts *)
    let map =
      String.Table.fold english ~init:String.Map.empty ~f:(fun ~key ~data acc ->
        String.Map.set acc ~key ~data )
    in
    String.Map.iteri map ~f:(fun ~key ~data ->
      let fmt_key = fmt key in
      W.string w_strings (sprintf "/* %s */\n%s = %s;\n\n" data fmt_key fmt_key);
      W.string w_json (json_pair fmt_key fmt_key first) );
    W.string w_json "\n}\n" );

  Eio.Flow.copy_string
    (sprintf
       !"✅ [%{Int63}ms] Generated '%s' and '%s' with:\n- %d unique strings\n\n"
       (time `Stop) path_strings path_json (String.Table.length english) )
    env#stdout

let write_other env ~outdir ~language english other =
  let time = Utils.Timing.start () in
  let path_strings = Filename.concat outdir (sprintf "%s.strings" language) in
  let path_json = Filename.concat outdir (sprintf "%s.json" language) in
  let n_left, n_right, n_both =
    Switch.run @@ fun sw ->
    let file_strings =
      Eio.Path.open_out ~sw ~create:Utils.Io.flags
        Eio.Path.(env#fs / outdir / sprintf "%s.strings" language)
    in
    let file_json =
      Eio.Path.open_out ~sw ~create:Utils.Io.flags Eio.Path.(env#fs / outdir / sprintf "%s.json" language)
    in
    let module W = Eio.Buf_write in
    W.with_flow file_strings @@ fun w_strings ->
    W.with_flow file_json @@ fun w_json ->
    let english_only = ref String.Map.empty in
    let other_only = ref String.Map.empty in
    let both = ref String.Map.empty in
    let add_entry map_ref ~line_strings ~line_json =
      map_ref := String.Map.set !map_ref ~key:line_strings ~data:line_json;
      None
    in
    let missing_translation key x =
      let fmt_key = fmt key in
      let line_strings = sprintf "/* MISSING TRANSLATION - %s */\n%s = %s;\n\n" x fmt_key fmt_key in
      add_entry english_only ~line_strings ~line_json:(fmt_key, fmt_key)
    in
    let _table =
      String.Table.merge english other ~f:(fun ~key -> function
        | `Left x -> missing_translation key x
        | `Both (x, y) when String.(key = y) -> missing_translation key x
        | `Both (x, y) ->
          let fmt_key = fmt key in
          let fmt_y = fmt y in
          let line_strings = sprintf "/* %s */\n%s = %s;\n\n" x fmt_key fmt_y in
          add_entry both ~line_strings ~line_json:(fmt_key, fmt_y)
        | `Right y when String.(key = y) -> None
        | `Right y ->
          (* No need to write "deprecated translations" to JSON *)
          let line_strings = sprintf "/* Not currently used */\n%s = %s;\n\n" (fmt key) (fmt y) in
          add_entry other_only ~line_strings ~line_json:() )
    in
    let first = ref true in
    (* Write headers *)
    W.string w_strings header;
    W.char w_json '{';
    let write_pairs map =
      String.Map.fold map ~init:0 ~f:(fun ~key:line_strings ~data:(x, y) acc ->
        W.string w_strings line_strings;
        W.string w_json (json_pair x y first);
        acc + 1 )
    in
    let n_left = write_pairs !english_only in
    let n_both = write_pairs !both in
    let n_right =
      String.Map.fold !other_only ~init:0 ~f:(fun ~key:line_strings ~data:() acc ->
        W.string w_strings line_strings;
        acc + 1 )
    in
    W.string w_json "\n}\n";
    n_left, n_right, n_both
  in

  Eio.Flow.copy_string
    (sprintf
       !"✅ [%{Int63}ms] Generated '%s' and '%s' with:\n\
         - %d new strings\n\
         - %d existing strings\n\
         - %d unused strings\n\n"
       (time `Stop) path_strings path_json n_left n_both n_right )
    env#stdout

let main env options = function
| Debug lang ->
  let string_parsers = Parsing.Basic.make_string_parsers () in
  List.iter options.targets ~f:(fun path ->
    Eio.Flow.copy_string (sprintf "\n>>> Debugging [%s]\n" path) env#stdout;
    let ({ slow_pug; template_script; _ } : common_options) = options in
    Eio.Path.with_open_in Eio.Path.(env#fs / path) @@ fun flow ->
    match lang, String.slice path (-4) 0 with
    | _, ".vue" ->
      let languages = Vue.parse ~path ~slow_pug flow in
      Vue.debug_template env ~path languages template_script lang
    | Pug, ".pug" -> (
      let source = Utils.Io.load_flow flow in
      let slow_parse () =
        let collector = Utils.Collector.create ~path in
        Quickjs.extract_to_collector collector Pug source;
        Vue.debug_template env ~path
          [ Pug { collector; length = String.length source } ]
          template_script lang
      in
      match slow_pug with
      | true -> slow_parse ()
      | false ->
        let on_ok parsed =
          Vue.debug_template env ~path [ Pug_native { parsed; length = None } ] template_script lang
        in
        let on_error ~msg =
          Eio.Flow.copy_string
            (sprintf "Falling back to official Pug parser for %s (%s)\n" path msg)
            env#stdout;
          slow_parse ()
        in
        Parsing.Basic.exec_parser ~on_ok ~on_error (Parsing.Pug.parser string_parsers) ~path
          ~language_name:"Pug" source )
    | Html, _ when String.is_suffix path ~suffix:".html" ->
      let on_ok parsed =
        Vue.debug_template env ~path [ Html { parsed; length = None } ] template_script lang
      in
      Parsing.Basic.exec_parser_eio ~on_ok Parsing.Html.parser ~path ~language_name:"Pug" flow
    | _ -> Eio.Flow.copy_string (sprintf "Nothing to do for file [%s]\n" path) env#stdout )
| Run ->
  let overall_time = Utils.Timing.start () in
  let outdir = options.outdir in
  (* Check current directory *)
  let strings_dir_files =
    let git_dir, strings_dir =
      Fiber.pair (fun () -> Utils.Io.directory_exists ".git") (fun () -> Utils.Io.directory_exists outdir)
    in
    if not (git_dir || strings_dir) then failwith "This program must be run from the root of your project";
    match strings_dir with
    | true -> Eio.Path.with_open_dir Eio.Path.(env#fs / outdir) Eio.Path.read_dir
    | false ->
      Utils.Io.mkdir_p env ~dir_name:outdir ~perms:0o751;
      []
  in

  (* English *)
  let english =
    let table = String.Table.create () in
    let counts = { vue = ref 0; pug = ref 0; html = ref 0; js = ref 0; ts = ref 0 } in
    let time = Utils.Timing.start () in
    Fiber.List.iter
      (fun directory ->
        let root = String.chop_suffix_if_exists ~suffix:"/" directory in
        let traversal =
          {
            rootlen = String.length root + 1;
            table;
            template_script = options.template_script;
            slow_pug = options.slow_pug;
            counts;
          }
        in
        traverse env traversal root)
      options.targets;
    let english =
      String.Table.map table ~f:(fun set -> String.Set.to_array set |> String.concat_array ~sep:", ")
    in
    let f ext i = sprintf "%d %s file%s" i ext (plural i) in
    let time = Int63.(time `Stop - Atomic.get Quickjs.init_time) in
    Eio.Flow.copy_string
      (sprintf
         !"✅ [%{Int63}ms] Processed %s, %s, %s, %s, and %s\n"
         time (f ".js" !(counts.js)) (f ".ts" !(counts.ts)) (f ".html" !(counts.html))
         (f ".vue" !(counts.vue)) (f ".pug" !(counts.pug)) )
      env#stdout;
    write_english env ~outdir english;
    english
  in

  (* Other languages *)
  let () =
    Fiber.List.iter
      (fun filename ->
        match String.chop_suffix ~suffix:".strings" filename with
        | Some "english" -> ()
        | Some language -> (
          let path = Filename.concat outdir filename in
          match Utils.Io.stat path with
          | { st_kind = S_REG; _ } ->
            let other = Eio.Path.with_open_in Eio.Path.(env#fs / path) (Parsing.Strings.parse ~path) in
            write_other env ~outdir ~language english other
          | _ -> () )
        | None -> ())
      strings_dir_files
  in
  Eio.Flow.copy_string (sprintf !"Completed. (%{Int63}ms)\n" (overall_time `Stop)) env#stderr

let () =
  let open Command in
  let open Command.Let_syntax in
  let common =
    let%map_open targets = "path" %: string |> sequence |> anon
    and outdir =
      flag_optional_with_default_doc "--output" ~aliases:[ "-o" ] ~full_flag_required:() string
        [%sexp_of: string] ~default:"strings" ~doc:"DIR Change default output directory"
    and use_ts =
      flag "--ts" ~full_flag_required:() no_arg
        ~doc:
          "Use this option if your HTML/Pug files use TypeScript as their scripting language in element \
           attributes like onClick=\"\""
    and slow_pug =
      flag "--slow-pug" ~aliases:[ "--sp" ] ~full_flag_required:() no_arg
        ~doc:
          "Use the official Pug parser. Much slower, especially on large files. Use this option if any \
           translation seems to be missing from a Pug file, and report the bug if this option fixes it."
    in
    { outdir; targets; template_script = (if use_ts then TS else JS); slow_pug }
  in
  let action =
    let open Param in
    let debug_pug =
      flag "--debug-pug" ~aliases:[ "--dp" ] ~full_flag_required:() no_arg
        ~doc:"Debug pug templates in .vue files"
      >>| Fn.flip Option.some_if (Debug Pug)
    in
    let debug_html =
      flag "--debug-html" ~aliases:[ "--dh" ] ~full_flag_required:() no_arg
        ~doc:"Debug html templates in .vue files"
      >>| Fn.flip Option.some_if (Debug Html)
    in
    choose_one [ debug_pug; debug_html ] ~if_nothing_chosen:(Default_to Run)
  in

  let handle_system_failure stderr = function
    | (Eio.Io _ as ex)
     |(Eio.Exn.Multiple _ as ex)
     |(Failure _ as ex)
     |(Core_unix.Unix_error _ as ex)
     |(Exn.Reraised _ as ex) ->
      let message = Utils.Exception.human ex in
      Eio.Flow.copy_string (sprintf !"❌ An error occured:\n%s\n" message) stderr;
      exit 1
    | exn -> raise exn
  in

  Param.both common action
  >>| (fun (common, action) () ->
        let program env = main env common action in
        Eio_main.run (fun env ->
          try program env with
          | exn -> handle_system_failure env#stderr exn ))
  |> basic ~summary:"Extract i18n strings - https://github.com/okTurtles/strings"
  |> Command_unix.run ~version
