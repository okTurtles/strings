open Core
open Lwt.Infix
open Lwt.Syntax

let version = "2.1.0"

let header = sprintf "/* Generated by okTurtles/strings v%s */\n\n" version

let () =
  Lwt.async_exception_hook :=
    fun ex ->
      let p1 =
        Lwt_io.write_line Lwt_io.stderr
          (sprintf "ðŸ’€ PLEASE REPORT THIS BUG. UNCAUGHT EXCEPTION: %s" (Utils.Exception.human ex))
      in
      let p2 = Lwt_unix.sleep 3. in
      Lwt.join [ p1; p2 ] >>= (fun () -> exit 2) |> ignore

let plural i = if i = 1 then "" else "s"

let pool = Lwt_pool.create 6 (fun () -> Lwt.return_unit)

let read_flags = Core_unix.[ O_RDONLY; O_NONBLOCK ]

let write_flags = Core_unix.[ O_WRONLY; O_NONBLOCK; O_TRUNC; O_CREAT ]

type counts = {
  vue: int ref;
  js: int ref;
  ts: int ref;
}

let process_file ~root strings count filename ~f:get_iter =
  Lwt_pool.use pool (fun () ->
      incr count;
      let+ iter = Lwt_io.with_file ~mode:Input ~flags:read_flags filename get_iter in
      iter ~f:(fun string ->
          let data = String.chop_prefix filename ~prefix:root |> Option.value ~default:filename in
          String.Table.update strings string ~f:(function
            | None -> String.Set.add String.Set.empty data
            | Some set -> String.Set.add set data)))

let rec traverse ~root counts strings js_file_errors directory =
  let* entries =
    Lwt_pool.use pool (fun () -> Lwt_unix.files_of_directory directory |> Lwt_stream.to_list)
  in
  Lwt_list.iter_p
    (function
      | filename when String.is_prefix ~prefix:"." filename || String.( = ) filename "node_modules" ->
        Lwt.return_unit
      | filename -> (
        let path = sprintf "%s/%s" directory filename in
        Lwt_unix.lstat path >>= function
        | { st_kind = S_REG; _ } when String.is_suffix ~suffix:".vue" filename ->
          process_file ~root strings counts.vue path ~f:(fun ic ->
              let* languages = Vue.parse ~filename ic in
              Vue.extract_strings ~filename js_file_errors languages JS)
        | { st_kind = S_REG; _ } when String.is_suffix ~suffix:".js" filename ->
          process_file ~root strings counts.js path ~f:(fun ic ->
              let* source = Lwt_io.read ic in
              let parsed = Queue.create () in
              let+ () = Parsing.Js_ast.strings_from_js ~filename:path parsed js_file_errors source in
              Queue.iter parsed)
        | { st_kind = S_REG; _ } when String.is_suffix ~suffix:".ts" filename ->
          process_file ~root strings counts.ts path ~f:(fun ic ->
              let* source = Lwt_io.read ic in
              let+ parsed = Quickjs.extract_ts source in
              Array.iter parsed)
        | { st_kind = S_DIR; _ } -> traverse ~root counts strings js_file_errors path
        | _ -> Lwt.return_unit))
    entries

let fmt s = Yojson.Basic.to_string (`String s)

let json_pair left right first =
  sprintf "%s\n  %s: %s"
    (if !first
    then begin
      first := false;
      ""
    end
    else ",")
    left right

let write_english english =
  let time = Utils.time () in
  let path_strings = "strings/english.strings" in
  let path_json = "strings/english.json" in
  let first = ref true in
  let* () =
    Lwt_io.with_file ~flags:write_flags ~mode:Output path_strings (fun oc_strings ->
        Lwt_io.with_file ~flags:write_flags ~mode:Output path_json (fun oc_json ->
            let* () = Lwt.join [ Lwt_io.write oc_strings header; Lwt_io.write_char oc_json '{' ] in
            let* () =
              String.Table.fold english ~init:Lwt.return_unit ~f:(fun ~key ~data acc ->
                  let fmt_key = fmt key in
                  let output_strings = sprintf "/* %s */\n%s = %s;\n\n" data fmt_key fmt_key in
                  let output_json = json_pair fmt_key fmt_key first in
                  let* () = acc in
                  Lwt_io.write oc_strings output_strings <&> Lwt_io.write oc_json output_json)
            in
            Lwt_io.write oc_json "\n}\n"))
  in
  Lwt_io.printlf
    !"âœ… [%{Int63}ms] Generated '%s' and '%s' with:\n- %d unique strings\n"
    (time ()) path_strings path_json (String.Table.length english)

let write_other ~language english other =
  let time = Utils.time () in
  let path_strings = sprintf "strings/%s.strings" language in
  let path_json = sprintf "strings/%s.json" language in
  let* n_left, n_right, n_both =
    Lwt_io.with_file ~flags:write_flags ~mode:Output path_strings (fun oc_strings ->
        Lwt_io.with_file ~flags:write_flags ~mode:Output path_json (fun oc_json ->
            let english_only = ref String.Map.empty in
            let other_only = ref String.Map.empty in
            let both = ref String.Map.empty in
            let add_entry map_ref ~line_strings ~line_json =
              map_ref := String.Map.set !map_ref ~key:line_strings ~data:line_json;
              None
            in
            let missing_translation key x =
              let fmt_key = fmt key in
              let line_strings =
                sprintf "/* MISSING TRANSLATION - %s */\n%s = %s;\n\n" x fmt_key fmt_key
              in
              add_entry english_only ~line_strings ~line_json:(fmt_key, fmt_key)
            in
            let _table =
              String.Table.merge english other ~f:(fun ~key -> function
                | `Left x -> missing_translation key x
                | `Both (x, y) when String.(key = y) -> missing_translation key x
                | `Both (x, y) ->
                  let fmt_key = fmt key in
                  let fmt_y = fmt y in
                  let line_strings = sprintf "/* %s */\n%s = %s;\n\n" x fmt_key fmt_y in
                  add_entry both ~line_strings ~line_json:(fmt_key, fmt_y)
                | `Right y when String.(key = y) -> None
                | `Right y ->
                  (* No need to write "deprecated translations" to JSON *)
                  let line_strings = sprintf "/* Not currently used */\n%s = %s;\n\n" (fmt key) (fmt y) in
                  add_entry other_only ~line_strings ~line_json:())
            in
            let first = ref true in
            let* () = Lwt.join [ Lwt_io.write oc_strings header; Lwt_io.write_char oc_json '{' ] in
            let write_pairs map =
              String.Map.fold map ~init:(Lwt.return 0) ~f:(fun ~key:line_strings ~data:(x, y) acc ->
                  let* () =
                    Lwt_io.write oc_strings line_strings <&> Lwt_io.write oc_json (json_pair x y first)
                  in
                  acc >|= succ)
            in
            let* n_left = write_pairs !english_only in
            let* n_both = write_pairs !both in
            let* n_right =
              String.Map.fold !other_only ~init:(Lwt.return 0) ~f:(fun ~key:line_strings ~data:() acc ->
                  let* () = Lwt_io.write oc_strings line_strings in
                  acc >|= succ)
            in
            let+ () = Lwt_io.write oc_json "\n}\n" in
            n_left, n_right, n_both))
  in
  Lwt_io.printlf
    !"âœ… [%{Int63}ms] Generated '%s' and '%s' with:\n\
      - %d new strings\n\
      - %d existing strings\n\
      - %d unused strings\n"
    (time ()) path_strings path_json n_left n_both n_right

let directory_exists path =
  let+ stat = Lwt_unix.stat path in
  match stat with
  | { st_kind = S_DIR; _ } -> true
  | { st_kind = _; _ } -> failwithf "%s already exists, but is not a directory" path ()
  | exception _ -> false

type common_options = {
  targets: string list;
  template_script: Vue.template_script;
}

let handle_system_failure = function
| (Failure _ as ex)
 |(Core_unix.Unix_error _ as ex)
 |(Exn.Reraised _ as ex) ->
  let message = Utils.Exception.human ex in
  let* () = Lwt_io.write_line Lwt_io.stderr (sprintf "âŒ An error occured:\n%s" message) in
  exit 1
| exn -> raise exn

type action =
  | Debug of Vue.Debug.t
  | Run

let main { targets; template_script } = function
| Debug lang ->
  Lwt_list.iter_s
    (fun filename ->
      let* () = Lwt_io.printlf "Debugging %s" filename in
      Lwt_io.with_file ~flags:read_flags ~mode:Input filename (fun ic ->
          let* languages = Vue.parse ~filename ic in
          Vue.debug_template ~filename languages lang template_script))
    targets
| Run ->
  let overall_time = Utils.time () in
  (* Check current directory *)
  let* strings_dir_files =
    let git_dir_p = directory_exists ".git" in
    let strings_dir_p = directory_exists "strings" in
    let* git_dir = git_dir_p in
    let* strings_dir = strings_dir_p in
    if not (git_dir || strings_dir) then failwith "This program must be run from the root of your project";
    match strings_dir with
    | true -> Lwt_unix.files_of_directory "strings" |> Lwt_stream.to_list
    | false ->
      let+ () = Lwt_unix.mkdir "strings" 0o751 in
      []
  in
  (* English *)
  let js_file_errors = Queue.create () in
  let* english =
    let english_list = String.Table.create () in
    let counts = { vue = ref 0; js = ref 0; ts = ref 0 } in
    let time = Utils.time () in
    let* () =
      Lwt_list.iter_p
        (fun directory ->
          let root = String.chop_suffix ~suffix:"/" directory |> Option.value ~default:directory in
          traverse ~root:(sprintf "%s/" root) counts english_list js_file_errors root)
        targets
    in
    let english =
      String.Table.map english_list ~f:(fun set ->
          String.Set.to_array set |> String.concat_array ~sep:", ")
    in
    let* () =
      let f ext i = sprintf "%d %s file%s" i ext (plural i) in
      let time = Int63.(time () - !Quickjs.init_time) in
      Lwt_io.printlf
        !"âœ… [%{Int63}ms] Processed %s, %s, and %s"
        time (f ".vue" !(counts.vue)) (f ".js" !(counts.js)) (f ".ts" !(counts.ts))
    in
    let+ () = write_english english in
    english
  in
  (* Other languages *)
  let* () =
    Lwt_list.iter_p
      (fun filename ->
        match String.chop_suffix ~suffix:".strings" filename with
        | Some "english" -> Lwt.return_unit
        | Some language -> (
          let path = sprintf "strings/%s" filename in
          Lwt_unix.stat path >>= function
          | { st_kind = S_REG; _ } ->
            let* other =
              Lwt_io.with_file ~mode:Input ~flags:read_flags path (Parsing.Strings.parse ~filename)
            in
            write_other ~language english other
          | _ -> Lwt.return_unit)
        | None -> Lwt.return_unit)
      strings_dir_files
  in
  (* JS parse errors *)
  let* () =
    match Queue.length js_file_errors with
    | 0 -> Lwt.return_unit
    | len ->
      let files =
        Queue.to_array js_file_errors
        |> Array.map ~f:(fun { filename; _ } -> sprintf "- %s" filename)
        |> String.concat_array ~sep:"\n"
      in
      Lwt_io.printlf "âŒ Encountered %d parsing error%s. File%s:\n%s\n" len (plural len) (plural len) files
  in
  Lwt_io.write_line Lwt_io.stdout (sprintf !"Completed. (%{Int63}ms)" (overall_time ()))

let () =
  let open Command in
  let open Command.Let_syntax in
  let common =
    let%map_open use_ts =
      flag "--ts" ~full_flag_required:() no_arg ~doc:"Interpret Vue templates as TypeScript"
    and targets = Param.("path" %: string |> sequence |> anon) in
    { targets; template_script = (if use_ts then TS else JS) }
  in
  let action =
    let open Param in
    let debug_pug =
      flag "--debug-pug" ~aliases:[ "--dp" ] ~full_flag_required:() no_arg
        ~doc:"Debug pug templates in .vue files"
      >>| Fn.flip Option.some_if (Debug Pug)
    in
    let debug_html =
      flag "--debug-html" ~aliases:[ "--dh" ] ~full_flag_required:() no_arg
        ~doc:"Debug html templates in .vue files"
      >>| Fn.flip Option.some_if (Debug Html)
    in
    choose_one [ debug_pug; debug_html ] ~if_nothing_chosen:(Default_to Run)
  in

  Param.both common action
  >>| (fun (common, action) () ->
        let program () = main common action in
        Lwt_main.run (Lwt.catch program handle_system_failure))
  |> Command.basic ~summary:"Extract i18n strings - https://github.com/okTurtles/strings"
  |> Command_unix.run ~version
